---
output:
  pdf_document: default
  html_notebook:
    code_folding: hide
  html_document:
    df_print: paged
params: 
    set_subtitle: "Relic_samples"
    snp_coverage_file: "~/mount/eager_outputs/2020-05-03-relic_samples/genotyping/double_eigenstrat_coverage.txt"
    sex_det_file: "~/mount/eager_outputs/2020-05-03-relic_samples/sex_determination/SexDet.txt"
    stats_table: "~/mount/eager_outputs/2020-05-03-relic_samples/multiqc/multiqc_data/multiqc_general_stats.txt"
    poseidon_geno: "~/mount/poseidon_packages/2020-05-03-relic_samples/2020-05-03-relic_samples.geno.txt"
    poseidon_snp: "~/mount/poseidon_packages/2020-05-03-relic_samples/2020-05-03-relic_samples.snp.txt"
    poseidon_ind: "~/mount/poseidon_packages/2020-05-03-relic_samples/2020-05-03-relic_samples.ind.txt"
    poseidon_janno: "~/mount/forged_packages/microscope_pca/microscope_pca.janno"
    pmmr_results_fn: "~/mount/automated_analysis/2020-05-03-relic_samples/pmmr/2020-05-03-relic_samples.pmmr.txt"
    pca_bg_annotation: "~/Software/github/Schiffels-Popgen/MICROSCOPE-processing-pipeline/project_reports/assets/bg_annotation.txt"
    pairwise_distance_fn: "~/mount/microscope_pca/pairwise_distances.mdist"
    pairwise_distance_id: "~/mount/microscope_pca/pairwise_distances.mdist.id"
    cred_file: "~/Software/github/Schiffels-Popgen/MICROSCOPE-processing-pipeline/.credentials"
    
title: "Extended preliminary data report"
subtitle: "`r params$set_subtitle`"
---

```{r load_libraries, message=FALSE, warning=FALSE, include=FALSE}
## Load required packages
library(dplyr)
library(tidyr)
library(ggplot2)
library(readr)
library(magrittr)
# library(knitr)
library(kableExtra)
library(forcats)
library(maps)
library(scales)
library(kableExtra)
library(ggrepel)
if(!require('remotes')) install.packages('remotes')
if(!require('sidora.core')) remotes::install_github("sidora-tools/sidora.core")
if(!require('poseidonR')) remotes::install_github('poseidon-framework/poseidonR')
library(sidora.core)
library(poseidonR)
require(RMariaDB)
# require(admixr)

## Cutoffs for genetic sex calls and expected ranges in sexdet plot.
#### Females
xx_xmin <- 0.7
xx_xmax <- 1.2
xx_ymin <- 0.0
xx_ymax <- 0.1
#### Males
xy_xmin <- 0.2
xy_xmax <- 0.6
xy_ymin <- 0.3
xy_ymax <- 0.6

sex_cutoffs <- tibble("Expected ranges"=c("XX", "XY"), 
                      xmin=c(xx_xmin, xy_xmin), 
                      xmax=c(xx_xmax, xy_xmax), 
                      ymin=c(xx_ymin, xy_ymin), 
                      ymax=c(xx_ymax, xy_ymax))

## Function to infer genetic sex from x/y rates
infer_sex <- function(sex_det, sex_cutoffs){
  ## Convert to a matrix with rownames so code is more legible and to avoid needing to pull() values from the tibbles.
  limits <- sex_cutoffs %>% tibble::column_to_rownames(var="Expected ranges") %>% as.matrix()
  sex_det <- sex_det %>%
    mutate("Genetic Sex" = ifelse(
      `x-rate` > limits["XX","xmin"] & 
        `x-rate` < limits["XX","xmax"] & 
        `y-rate` > limits["XX","ymin"] & 
        `y-rate` < limits["XX","ymax"], "F",
      ifelse(`x-rate` > limits["XY","xmin"] & 
               `x-rate` < limits["XY","xmax"] & 
               `y-rate` > limits["XY","ymin"] & 
               `y-rate` < limits["XY","ymax"], "M",
             "Unknown"))) %>%
    select(`Sample`, `Genetic Sex`)
  return(sex_det)
}
```

# Descriptive statistics of sequencing data

```{r load_general_stats, echo=FALSE, message=FALSE}
library_info <- read_tsv(params$stats_table) %>%
  filter(!grepl("_S0_",Sample)) %>% 
  filter(grepl("TF|SG",Sample)) %>% 
  select(Sample,
    "Sequenced Reads"=`Samtools Flagstat (pre-samtools filter)_mqc-generalstats-samtools_flagstat_pre_samtools_filter-flagstat_total`,
    "Mapped Reads" = `Samtools Flagstat (pre-samtools filter)_mqc-generalstats-samtools_flagstat_pre_samtools_filter-mapped_passed`,
    "Endogenous DNA (%)"= `endorSpy_mqc-generalstats-endorspy-endogenous_dna`,
    "% of Sequence Duplication" = `Picard_mqc-generalstats-picard-PERCENT_DUPLICATION`,
    "Damage 1st bp 3'" = `DamageProfiler_mqc-generalstats-damageprofiler-3_Prime1`
         ) %>%
  mutate(`% of Sequence Duplication`=`% of Sequence Duplication`*100) %>%
  arrange(Sample)
library_info %>% kable(format.args=list(big.mark = ',', digits=3))  %>% kable_styling(full_width=T)
```
\newpage

# Sex determination and SNP coverage

The table below includes the sample name, archaeological ID, genetic sex and SNP coverage of each individual. Genetic Sex is abbreviated as follows:

* M : Male
* F : Female
* Unknown (usually due to low coverage.)

Individuals that have too few covered SNPs (< 10,000) for population genetic analysis are shown in red.

```{r gather snp coverage data, echo=FALSE, message=FALSE}
## Load and parse coverage stats
snp_cov<-read_tsv(params$snp_coverage_file, col_names=c("#Sample", "#SNPs_Covered", "#SNPs_Total"), col_types='cii', skip=1) %>% 
  rename("Sample"="#Sample","# SNPs Covered" = "#SNPs_Covered", "Out of a maximum of" = "#SNPs_Total") %>%
  arrange(Sample) ## Sort by individual ID so bad_cov gets the correct indices for highlighting in the table.


bad_cov <- which(snp_cov$`# SNPs Covered` < 10000)
good_cov_inds <- snp_cov$Sample[which(snp_cov$`# SNPs Covered` >= 10000)]

```

```{r gather sexdet data, message=FALSE, include=FALSE}
## Load and parse sex determination stats.
sex_det <- read_tsv(params$sex_det_file, col_names=c("#Sample", "#SnpsAut", "#SNPsX", "#SnpsY", "NrAut", "NrX", "NrY", "x-rate", "y-rate"), col_types='ciiiiiidd', skip=1) %>%
  separate(`#Sample`, into=c("Sample"), sep="[._]", extra='drop') %>%
  select(`Sample`, `x-rate`, `y-rate`) %>%
  infer_sex(sex_cutoffs=sex_cutoffs)
```

```{r arch_IDs from pandora, message=FALSE, include=FALSE}
## Load ArchIDs from pandora using sidora
con <- get_pandora_connection(params$cred_file)
pandora_data <- get_df("TAB_Individual", con) %>% 
  filter(`individual.Full_Individual_Id` %in% sex_det$Sample) %>%
  select(`individual.Full_Individual_Id`, `individual.Archaeological_ID`) %>%
  rename("Sample" = `individual.Full_Individual_Id`, "Archaeological ID" = `individual.Archaeological_ID`)
RMariaDB::dbDisconnect(con)
```

```{r print coverage_sexdet_arch_id table, echo=FALSE, message=FALSE}
sex_det_pandora <- full_join(sex_det, pandora_data, by="Sample")
snp_cov_sex_pandora <- full_join(snp_cov, sex_det_pandora, by="Sample") %>% select(`Sample`, `Archaeological ID`, `Genetic Sex`, `# SNPs Covered`, `Out of a maximum of`) %>%
  arrange(Sample)

snp_cov_sex_pandora %>% kable(format.args=list(big.mark = ',')) %>% kable_styling(latex_options = "hold_position") %>%
  row_spec(bad_cov, bold = F, color = "red")
```
**These results are liable to change with any addition of further sequencing data.**
\newpage

The following figure shows the relative coverage of each individual on the X and Y chromosomes, and the associated error bars for each measure, as well as the expected position for males and females on such a plot. The expected ranges displayed here were used as the cutoffs for the inference of genetic sex shown in the table on page 2.

```{r sexdet plot, echo=FALSE, fig.height=7, fig.width=6, message=FALSE, warning=FALSE}
sex_det <- read_tsv(params$sex_det_file, col_names=c("#Sample", "#SnpsAut", "#SNPsX", "#SnpsY", "NrAut", "NrX", "NrY", "x-rate", "y-rate", "Err(x-rate)", "Err(y-rate)"), col_types='ciiiiiidddd', skip=1) %>%
  separate(`#Sample`, into=c("Sample"), sep="[._]", extra='drop') %>%
  mutate(xmin=`x-rate`-`Err(x-rate)`,
         xmax=`x-rate`+`Err(x-rate)`,
         ymin=`y-rate`-`Err(y-rate)`,
         ymax=`y-rate`+`Err(y-rate)`,
         `total_snps`=NrAut+NrY+NrX
  ) %>%
  select(Sample, x=`x-rate`, xmin, xmax, y=`y-rate`, ymin, ymax, "Total Snps"=total_snps)

ggplot(sex_det) +
  geom_point(aes(x=x, y=y, alpha=`Total Snps`), size=2.5) +
  geom_rect(data=sex_cutoffs, aes(xmin=xmin, xmax=xmax, ymin=ymin,ymax=ymax, fill=`Expected ranges`), alpha=0.4) +
  geom_errorbar(aes(x=x, ymin=ymin, ymax=ymax, alpha=`Total Snps`), width=0) +
  geom_errorbarh(aes(y=y, xmin=xmin, xmax=xmax, alpha=`Total Snps`), height=0) +
  geom_text_repel(aes(label=Sample, x=x, y=y), max.overlaps = 50, size=2) +
  scale_alpha(range=c(0.3,1), labels=function(x) {format(x, big.mark = ",", decimal.mark = ".", scientific = F)}) +
  theme_classic() +
  theme(legend.position = 'bottom', 
        legend.direction="horizontal", 
        legend.margin=margin(r=20,l=20), 
        legend.box='vertical'
        ) +
  xlab("Relative coverage on the X chromosome") +
  ylab("Relative coverage on the Y chromosome") +
  ggtitle("Genetic sex determination plot") +
  coord_cartesian(xlim=c(0,1.2), ylim=c(0,0.8)) + 
  expand_limits(x=c(0,1.2),y=c(0,0.8))
```

\newpage

# Pairwise mismatch rate between individuals
The pairwise genotype mismatch rate (pMMR) between different individuals, can be indicative of genetic kinship. Unrelated individuals will have a higher pMMR, with multiple unrelated pairs forming a plateau on the upper-right end of the figure. The pMMR of genetically related individuals is lowered proportionally to the closeness of their relationship. Some rough expected values for pMMR based on an underlying relationship are:

* Identical Twins/ Same individual: 50% of plateau value
* First Degree: 75% of plateau value
* Second Degree: 87.5% of plateau value

**It is often difficult to tell apart second from third degree relationships.** To do that, we often employ additional analytical methods once a suspected genetic relationship is identified with pMMR.

The colour of the points indicates the relative confidence around the pMMR. Red points are unreliable, gray points are somewhat reliable, and black points are reliable estimates of the pMMR. The numbers above each point correspond to the number of SNPs used in the calculation of the pMMR between each pair of individuals.

```{r import and plot pMMR, echo=FALSE, fig.height=5, fig.width=8.25, message=FALSE}
pmmr_data<-read_tsv(params$pmmr_results_fn) %>%
  mutate(Label=paste(Ind1,Ind2, sep="-"), colour=if_else(nSNPs < 50, "<50 SNPs", if_else(nSNPs < 100, "<100 SNPs","100+ SNPs"))) %>%
  ## Remove rows with p Mismatch == NA which are invdividuals with 0 overlapping SNPs. Also remove rows with pMMR=0 or 1, which are caused by comparisons of individuals with low overlapping SNPs (usually less that 10). They can swamp other results in some datasets
  filter(!is.na(pMismatch), pMismatch > 0, pMismatch < 1)

if (nrow(pmmr_data) > 1) {
ggplot(pmmr_data, aes(x=fct_reorder(Label, pMismatch), y=pMismatch, col=factor(colour, levels=c("<50 SNPs","<100 SNPs","100+ SNPs")))) +
  scale_color_manual(values=c("<50 SNPs"="red","<100 SNPs"="grey","100+ SNPs"="black")) +
  labs(color = "number of\noverlapping\nSNPs") +
  geom_point(size=2) + 
  geom_text(aes(label=nSNPs, y=pMismatch+0.05), size=1.5, angle=90) +
  theme_classic(base_size=13) + 
  theme(axis.text.x = element_text(angle=90, hjust=1, vjust=0.5), legend.title.align = 0.5) +
  expand_limits(x = 0, y = 0) +
  xlab('') +
  ylab("pairwise genotype mismatch rate")
} else {
  print("Pairwise mismatch rate cannot be calculated for a single individual.")
}
```
\newpage

# Principal component analysis

```{r import distance matrix janno and pca annotation, include=FALSE}
dm_inds <- readr::read_tsv(params$pairwise_distance_id, 
                           col_types="cc", 
                           col_names=c("Population", "Individual")
                           )

dm <- data.table::fread(file=params$pairwise_distance_fn, 
                        sep = " ", 
                        header=F, 
                        na.strings=c("NaN","nan"), 
                        strip.white=T
                        ) %>%
  as.matrix()
colnames(dm) <- dm_inds$Individual
rownames(dm) <- dm_inds$Individual

janno_info <- read_janno(params$poseidon_janno, to_janno=F)
## Exclude strange haploid modern Spanish dataset.
exclude_inds <- janno_info %>% filter(Publication_Status == "BiaginiEJHG2019") %>% select(Individual_ID)

##Load list of colours, population groupings and 3 character codes for modern pops.
pop_labels <- read_tsv(params$pca_bg_annotation, col_names = c("pop","label","region","colour"), col_types = 'ccci')
```

```{r subset distances, include=FALSE}
## Get the indices of used individuals with more than 15000 SNPs
indices <- ((dm_inds$Population %in% pop_labels$pop & ! (dm_inds$Individual %in% exclude_inds$Individual_ID)) | dm_inds$Individual %in% good_cov_inds)
## Remove sharing with unused individuals
dm <- dm[c(indices),c(indices)]
```

The following plot shows how the ancient individuals (in black) relate to present-day West Eurasian populations. The distance between individuals roughly correlates with genetic distances. The plot only includes ancient individuals with sufficient genomic coverage (if any).

The colour used in the plotting of present-day individuals indicates rough geographic regions, as follows:

* Caucasus: \textcolor[HTML]{F8766D}{red}
* Near East: \textcolor[HTML]{A3A500}{olive}
* South Europe: \textcolor[HTML]{00B0F6}{light blue}
* Central/North Europe: \textcolor[HTML]{E76BF3}{magenta}
* Northeaster/Eastern Europe: \textcolor[HTML]{00BF7D}{green}

```{r do MDS, echo=FALSE}
components <- stats::cmdscale(dm)
colnames(components) <- c("PC1", "PC2")
components <- components %>% 
  as_tibble(rownames = "Ind") %>%
  mutate(bg=if_else(Ind %in% snp_cov$Sample, F, T)) %>%
  left_join(., janno_info, by=c("Ind"="Individual_ID")) %>%
  left_join(., pop_labels, by=c("Group_Name"="pop"))

## Infer PC orientation and flip if necessary
Chuvash_ind <- components %>% filter(Ind == "Ttr-481")
BedouinB_ind <- components %>% filter(Ind == "HGDP00636")
if (Chuvash_ind$PC1 > BedouinB_ind$PC1) {
  components <- components %>% mutate(PC1 = -PC1)
}
if (Chuvash_ind$PC2 < BedouinB_ind$PC2) {
  components <- components %>% mutate(PC2 = -PC2)
}
```

```{r plot MDS, echo=FALSE, fig.height=6, fig.width=7}
ggplot()+
  coord_equal() +
  scale_x_continuous(minor_breaks=seq(-2,2,0.005), breaks=seq(-2,2,0.01)) +
  scale_y_continuous(minor_breaks=seq(-2,2,0.005), breaks=seq(-2,2,0.01)) +
  theme_minimal(base_size=13) +
  geom_text(data=components %>% filter(bg==T), aes(x=PC1, y=PC2, label=label, col=factor(colour)), 
            alpha=0.4, size=2, show.legend=F) +
  geom_point(data=components %>% filter(bg==F), aes(x=PC1, y=PC2)) +
  geom_text_repel(data=components %>% filter(bg==F), aes(x=PC1, y=PC2, label=Ind), max.overlaps = Inf, size=2.5) +
  xlab(paste0("PC1")) +
  ylab(paste0("PC2")) +
  labs(shape = "Ancient Individual")

```
